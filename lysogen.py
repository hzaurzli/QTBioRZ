# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'activity.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys,os
import time
from PyQt5 import QtCore, QtGui, QtWidgets, Qt
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
import pandas as pd
import numpy as np
import pickle as pkl
import subprocess
import shutil
from collections import Counter
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
import subprocess as sub
import torch
from datasets import DatasetDict,Dataset
import argparse
import pandas as pd
import pyarrow as pa
import numpy as np
import pickle as pkl
from scipy.special import softmax
from transformers import AutoTokenizer
from transformers import DataCollatorWithPadding
from transformers import AutoModelForSequenceClassification
from transformers import BertTokenizer, LineByLineTextDataset
from transformers import BertConfig, BertForMaskedLM, DataCollatorForLanguageModeling
from transformers import TrainingArguments, Trainer



class Lysogen_Form(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setWindowTitle("Lysogen")
        self.resize(762, 624)

        self.pushButton_12 = QtWidgets.QPushButton("Choose",self)
        self.pushButton_12.setGeometry(QtCore.QRect(470, 160, 111, 51))
        font = QtGui.QFont()
        font.setPointSize(15)
        self.pushButton_12.setFont(font)
        self.pushButton_12.setObjectName("pushButton_12")
        self.pushButton_12.clicked.connect(self.read_file12)

        self.textBrowser_11 = QtWidgets.QTextBrowser(self)
        self.textBrowser_11.setGeometry(QtCore.QRect(70, 160, 331, 51))
        self.textBrowser_11.setObjectName("textBrowser_11")

        self.label_25 = QtWidgets.QLabel("Input file (Fa)",self)
        self.label_25.setGeometry(QtCore.QRect(150, 90, 181, 51))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(20)
        self.label_25.setFont(font)
        self.label_25.setObjectName("label_25")

        self.textBrowser_12 = QtWidgets.QTextBrowser(self)
        self.textBrowser_12.setGeometry(QtCore.QRect(70, 310, 331, 51))
        self.textBrowser_12.setObjectName("textBrowser_12")

        self.pushButton_13 = QtWidgets.QPushButton("Choose",self)
        self.pushButton_13.setGeometry(QtCore.QRect(470, 310, 111, 51))
        font = QtGui.QFont()
        font.setPointSize(15)
        self.pushButton_13.setFont(font)
        self.pushButton_13.setObjectName("pushButton_13")
        self.pushButton_13.clicked.connect(self.read_file13)

        self.label_26 = QtWidgets.QLabel("Lysogen file",self)
        self.label_26.setGeometry(QtCore.QRect(150, 250, 181, 51))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(20)
        self.label_26.setFont(font)
        self.label_26.setObjectName("label_26")

        self.textBrowser_7 = QtWidgets.QTextBrowser(self)
        self.textBrowser_7.setGeometry(QtCore.QRect(70, 440, 331, 111))
        self.textBrowser_7.setObjectName("textBrowser_7")

        self.label_27 = QtWidgets.QLabel("Status",self)
        self.label_27.setGeometry(QtCore.QRect(190, 380, 181, 51))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(20)
        self.label_27.setFont(font)
        self.label_27.setObjectName("label_27")

        self.label_28 = QtWidgets.QLabel("Lysogen",self)
        self.label_28.setGeometry(QtCore.QRect(300, 20, 181, 51))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(20)
        self.label_28.setFont(font)
        self.label_28.setObjectName("label_28")

        self.pushButton_14 = QtWidgets.QPushButton("Run",self)
        self.pushButton_14.setGeometry(QtCore.QRect(480, 470, 81, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(20)
        self.pushButton_14.setFont(font)
        self.pushButton_14.setObjectName("pushButton_14")
        self.pushButton_14.clicked.connect(self.predict)

        ## show window
        self.show()

    def read_file12(self):
        openfile_name = QtWidgets.QFileDialog.getOpenFileName(self, 'choose file', '')[0]
        print(openfile_name)
        self.textBrowser_11.setText(openfile_name)

    def read_file13(self):
        openfile_name = QtWidgets.QFileDialog.getExistingDirectory(self,"choose directory", '')
        print(openfile_name)
        self.textBrowser_12.setText(openfile_name)

    def predict(self):
        try:
            self.textBrowser_7.setText('Running! please wait(5-8mins)'+'\n'+'If no response,never close window!!!')
            QApplication.processEvents()  # 逐条打印状态

            def read_abc(position, output):
                with open(output, 'w') as abc:
                    with open(position) as tab:
                        for line in tab:
                            line = line.replace('\n', '')
                            li = line.split('\t')
                            if li[0] != li[1]:
                                lines = li[0] + '\t' + li[1] + '\t' + li[10] + '\n'
                                abc.write(lines)
                    tab.close()
                abc.close()

            out_fn = self.textBrowser_12.toPlainText() + '/'
            transformer_fn = self.textBrowser_12.toPlainText() + '/'
            length = 3000
            contigs = self.textBrowser_11.toPlainText()

            if not os.path.isdir(out_fn):
                os.makedirs(out_fn)

            rec = []
            for record in SeqIO.parse(contigs, 'fasta'):
                if len(record.seq) > int(length):
                    rec.append(record)
            SeqIO.write(rec, out_fn + 'filtered_contigs.fa', 'fasta')

            try:
                p = sub.Popen(r'.\tools\prodigal.exe -i ' + out_fn + 'filtered_contigs.fa -a ' + out_fn + 'test_protein.fa -f gff -p meta')
                p.wait()
            except:
                QMessageBox.critical(self, "error", "check fasta file format!")

            try:
                # create database
                p = sub.Popen(r'.\tools\diamond makedb --threads 2 --in ./models/PhaTYP/database/database.fa -d ' + out_fn + 'database.dmnd',
                    shell=False)
                p.wait()
                # running alignment
                p = sub.Popen(r'.\tools\diamond blastp --threads 2 --sensitive -d ' + out_fn + 'database.dmnd -q ' + out_fn + 'test_protein.fa -o ' + out_fn + 'results.tab -k 1',
                    shell=False)
                p.wait()

                read_abc(out_fn + 'results.tab', out_fn + 'results.abc')
            except:
                QMessageBox.critical(self, "error", "check fasta file format!")

            # Load dictonary and BLAST results D:\tools\Pycharm\pyqt\models\PhaTYP\database
            proteins_df = pd.read_csv('./models/PhaTYP/database/proteins.csv')
            proteins_df.dropna(axis=0, how='any', inplace=True)
            pc2wordsid = {pc: idx for idx, pc in enumerate(sorted(set(proteins_df['cluster'].values)))}
            protein2pc = {protein: pc for protein, pc in
                          zip(proteins_df['protein_id'].values, proteins_df['cluster'].values)}
            blast_df = pd.read_csv(out_fn + "results.abc", sep='\t', names=['query', 'ref', 'evalue'])

            # Parse the DIAMOND results
            contig2pcs = {}
            for query, ref, evalue in zip(blast_df['query'].values, blast_df['ref'].values, blast_df['evalue'].values):
                conitg = query.rsplit('_', 1)[0]
                idx = query.rsplit('_', 1)[1]
                pc = pc2wordsid[protein2pc[ref]]
                try:
                    contig2pcs[conitg].append((idx, pc, evalue))
                except:
                    contig2pcs[conitg] = [(idx, pc, evalue)]

            # Sorted by position
            for contig in contig2pcs:
                contig2pcs[contig] = sorted(contig2pcs[contig], key=lambda tup: tup[0])

            # Contigs2sentence
            contig2id = {contig: idx for idx, contig in enumerate(contig2pcs.keys())}
            id2contig = {idx: contig for idx, contig in enumerate(contig2pcs.keys())}
            sentence = np.zeros((len(contig2id.keys()), 300))
            sentence_weight = np.ones((len(contig2id.keys()), 300))
            for row in range(sentence.shape[0]):
                contig = id2contig[row]
                pcs = contig2pcs[contig]
                for col in range(len(pcs)):
                    try:
                        _, sentence[row][col], sentence_weight[row][col] = pcs[col]
                        sentence[row][col] += 1
                    except:
                        break

            # propostion
            rec = []
            for key in blast_df['query'].values:
                name = key.rsplit('_', 1)[0]
                rec.append(name)
            counter = Counter(rec)
            mapped_num = np.array([counter[item] for item in id2contig.values()])

            rec = []
            for record in SeqIO.parse(out_fn + 'test_protein.fa', 'fasta'):
                name = record.id
                name = name.rsplit('_', 1)[0]
                rec.append(name)
            counter = Counter(rec)
            total_num = np.array([counter[item] for item in id2contig.values()])
            proportion = mapped_num / total_num

            # Store the parameters
            pkl.dump(sentence, open(transformer_fn + 'sentence.feat','wb'))
            pkl.dump(id2contig, open(transformer_fn + 'sentence_id2contig.dict','wb'))
            pkl.dump(proportion, open(transformer_fn + 'sentence_proportion.feat','wb'))
            pkl.dump(pc2wordsid, open(transformer_fn + 'pc2wordsid.dict','wb'))

            feat = pkl.load(open(transformer_fn + 'sentence.feat', 'rb'))
            pcs = pkl.load(open('./models/PhaTYP/database/pc2wordsid.dict', 'rb'))
            id2pcs = {item: key for key, item in pcs.items()}
            text = []
            label = []
            for line in feat:
                sentence = ""
                flag = 0
                for i in range(len(line) - 2):
                    if line[i] - 1 == -1:
                        flag = 1
                        sentence = sentence[:-1]
                        break
                    sentence = sentence + id2pcs[line[i] - 1] + ' '
                if flag == 0:
                    sentence = sentence[:-1]
                text.append(sentence)
                label.append(1)

            feat_df = pd.DataFrame({'label': label, 'text': text})
            feat_df.to_csv(transformer_fn + '/bert_feat.csv', index=None)

            out = out_fn + 'lysogen_prediction.csv'

            out_dir = os.path.dirname(out)
            if out_dir != '':
                if not os.path.isdir(out_dir):
                    os.makedirs(out_dir)

            id2contig = pkl.load(open(transformer_fn + 'sentence_id2contig.dict', 'rb'))
            bert_feat = pd.read_csv(transformer_fn + 'bert_feat.csv')

            SENTENCE_LEN = 300  # len
            NUM_TOKEN = 45583  # PC

            CONFIG_DIR = "./models/PhaTYP/config"
            OUTPUT_DIR = "finetune"

            # load the token configuration
            tokenizer = BertTokenizer.from_pretrained(CONFIG_DIR, do_basic_tokenize=False)

            def preprocess_function(examples):
                return tokenizer(examples["text"], truncation=True)

            train = pa.Table.from_pandas(bert_feat)
            test = pa.Table.from_pandas(bert_feat)
            train = Dataset(train)
            test = Dataset(test)

            data = DatasetDict({"train": train, "test": test})

            tokenized_data = data.map(preprocess_function, batched=True)
            data_collator = DataCollatorWithPadding(tokenizer=tokenizer)
            model = AutoModelForSequenceClassification.from_pretrained("./models/PhaTYP/model/", num_labels=2)

            training_args = TrainingArguments(
                output_dir='./models/PhaTYP/results',
                overwrite_output_dir=False,
                do_train=True,
                do_eval=True,
                learning_rate=2e-5,
                num_train_epochs=10,
                per_device_train_batch_size=32,
                per_device_eval_batch_size=32,
                weight_decay=0.01,
            )

            trainer = Trainer(
                model=model,
                args=training_args,
                train_dataset=tokenized_data["train"],
                eval_dataset=tokenized_data["test"],
                tokenizer=tokenizer,
                data_collator=data_collator,
            )

            with torch.no_grad():
                pred, label, metric = trainer.predict(tokenized_data["test"])

            prediction_value = []
            for item in pred:
                prediction_value.append(softmax(item))
            prediction_value = np.array(prediction_value)

            all_pred = []
            all_score = []
            for score in prediction_value:
                pred = np.argmax(score)
                if pred == 1:
                    all_pred.append('temperate')
                    all_score.append(score[1])
                else:
                    all_pred.append('virulent')
                    all_score.append(score[0])

            pred_csv = pd.DataFrame({"Contig": id2contig.values(), "Pred": all_pred, "Score": all_score})
            pred_csv.to_csv(out, index=False)
            self.textBrowser_7.setText('Finished!!!'+'\n'+'lysogen_prediction.csv is your result!!!')

        except:
            QMessageBox.critical(self, "error", "check fasta file format!")


if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    mc = Lysogen_Form()
    mc.show()
    app.exec_()
